{ stdenv

, systemPackages
, haskellPackages 

, os   ? stdenv.buildPlatform.parsed.kernel.name  #TODO
, arch ? stdenv.buildPlatform.parsed.cpu.name     #TODO
, impl ? haskellPackages.ghc.haskellCompilerName  #TODO

, examples     ? true
, test-doctest ? true
, test-unit    ? true
, test-static  ? false
}:
########################################

/* e.g.

  > nixpkgs = import <nixpkgs> {}
  > :a nixpkgs.pkgs
  
  > stdenv.buildPlatform.parsed.kernel.name
  "linux"

  > stdenv.buildPlatform.parsed.cpu.name 
  "x86_64"

  > haskellPackages.ghc.haskellCompilerName 
  "ghc-8.2.2"

  # `haskellCompilerName` is correct, 
  # even when the package isn't buildable
  # TODO confirm. 

  > haskell.packages.ghcjs.ghc.haskellCompilerName 
  "ghcjs"

*/


/* e.g.

  > nixpkgs = import <nixpkgs> {}
  > :a nixpkgs.pkgs
  
  > haskell.compiler.ghc841.haskellCompilerName 
  "ghc-8.4.1"

  > haskell.compiler.integer-simple.ghc841.haskellCompilerName 
  "ghc-8.4.1"

  > haskell.compiler.ghcjs.haskellCompilerName 
  "ghcjs"

*/

/*NOTES 

the `nix` flag names and defaults (above) come from their respective `cabal` flags (below):

  flag examples
    default: True
  
  flag test-doctest
    default: True
  
  flag test-unit
    default: True 
  
  flag test-static
    default: False
*/

# { system    ? builtins.currentSystem
# #
# , _os       ? null
# , _arch     ? null
# , _compiler ? null
# #
# , _examples ? true
# }:

# { mkDerivation, base, bytestring, containers, data-default-class
# , deepseq, directory, doctest, exceptions, generic-deriving
# , hashable, mtl, process, safe, safe-exceptions, split, stdenv, stm
# , string-conv, tasty, tasty-hunit, template-haskell, text, time
# , transformers, unordered-containers, vector, vinyl
# }:
  
#   libraryHaskellDepends = [
#   ] ++ with haskellPackages; [
#     base bytestring containers data-default-class deepseq directory
#     exceptions generic-deriving hashable mtl process safe
#     safe-exceptions split stm string-conv template-haskell text time
#     transformers unordered-containers vector vinyl
#   ] ++ with systemPackages; [
#   ];

/*NOTES

`spiros.nix` is automatically (re)generated by `cabal2nix`.

`spiros.cabal.nix` is manually written, to losslessly represent `spiros.cabal`. 

i.e...

- it explicitly requires all configuration variables that `cabal` supports, including `flags`:
* this file is a binary function, rather than unary;
* the first positional argument has default values for all its keyword arguments, consistent with the `.cabal` file. 

(btw, this `config` argument is a shallow record ("attr set"), and it can be named `config`, i.e. `{...}@config:`. Neither `config` nor `system` are currently (2018) the name of any package on hackage, fwiw.) 

- it correctly uses those flags within `nix`, just like `cabal` does:
* pruning/adding dependencies;
* enabling/disabling different components (lib, exe, test, bench); 
* etc. 

this `config` argument represents a haskell `List ConfVar`:

    -- package Cabal-2.2.0.0
    -- module Distribution.Types.GenericPackageDescription

    data ConfVar
      = OS   OS
      | Arch Arch
      | Flag FlagName           
      | Impl CompilerFlavor VersionRange

that is, `config` looks like:

  { system    ? ...
  # builtin cabal flags
  , _os       ? ...
  , _arch     ? ...
  , _compiler ? ...
  # custom cabal flags (from `flag` stanzas within the `.cabal`)
  , <flag>    ? ...
  , <flag>    ? ...
  ...
  }

which in typed pseudo-`nix` is:

  { system    :: String
  # `null` means what?
  , _os       :: Maybe String
  , _arch     :: Maybe String
  , _compiler :: Maybe String
  # 
  , <flag>    :: Bool
  , <flag>    :: Bool
  ...
  }

for example:

  # spiros.cabal.nix

  { system    ? builtins.currentSystem
  #
  , _os       ? null
  , _arch     ? null
  , _compiler ? null
  #
  , _examples ? true
  }:

  ... 

note, `currentSystem` is the `Platform`, with syntax like:

  <arch>-<os>

e.g.:

  nix-repl> builtins.currentSystem 
  "x86_64-linux"



*/

########################################
let

inherit (stdenv.lib) licenses;
inherit (systemPackages.lib) concatLists;
inherit (haskellPackages) mkDerivation;

flags = {
 inherit os arch impl;
 inherit examples test-doctest test-unit test-static;
};

in
########################################
let

libraryHaskellDepends = concatLists [

    (with haskellPackages; [
      base bytestring containers data-default-class deepseq
      directory exceptions generic-deriving hashable mtl
      process safe safe-exceptions split stm string-conv
      template-haskell text time transformers unordered-containers
      vector vinyl
    ])

    (with systemPackages; [
    ])

];

testSuite = {impl,test-doctest,...}: {
  
};

testHaskellDepends = concatLists [

    (with haskellPackages; [
      base doctest tasty tasty-hunit
    ])

    (with systemPackages; [
    ])

];

in
########################################
mkDerivation {

  pname   = "spiros";
  version = "0.2";
  src     = ./.;

  homepage    = "http://github.com/sboosali/spiros#readme";
  description = "my custom prelude";
  license     = licenses.bsd3;

  inherit libraryHaskellDepends;
  inherit testHaskellDepends;

}
########################################
